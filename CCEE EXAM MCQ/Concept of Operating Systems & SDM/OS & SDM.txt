A) Operating System Topics
  1. Introduction to OS
  2. Introduction to Linux
  3. Shell Programming
  4. Processes
  5. Signals
  6. Threads
  7. Memory Management
  8. Virtual Memory
  9. DeadLock
  10.Inter Process Communication


Answers of Question Paper(OS)
1. D
2. C
3. A
4. D
5. D
6. D
7. A
8. 
9. A
10.A
11.D
12.C
13.C
14.C
15.
16.B
17.A
18.A
19.A
20.A
21.B
22.B
23.B
24.D
25.A
26.C
27.
28.D
29.A
30.
31.B
32.
33.A
34.A
35.A
36.C
37.C
38.B
39.
40.



Imp:
#Memory Allocation Strategies
A)Contiguous Memory Allocation:
1) First Fit
The first-fit algorithm searches for the first free partition that is large enough to accommodate the process. The operating system starts searching from the beginning of the memory and allocates the first free partition that is large enough to fit the process.
For example, suppose we have the following memory partitions:
| 10 KB | 20 KB | 15 KB | 25 KB | 30 KB |
Now, a process requests 18 KB of memory. The operating system starts searching from the beginning and finds the first free partition of 20 KB. It allocates the process to that partition and keeps the remaining 2 KB as free memory.

2) Best Fit
The best-fit algorithm searches for the smallest free partition that is large enough to accommodate the process. The operating system searches the entire memory and selects the free partition that is closest in size to the process.
For example, suppose we have the following memory partitions:
| 10 KB | 20 KB | 15 KB | 25 KB | 30 KB |
Now, a process requests 18 KB of memory. The operating system searches for the smallest free partition that is larger than 18 KB, and it finds the partition of 20 KB. It allocates the process to that partition and keeps the remaining 2 KB as free memory.

3) Worst Fit
The worst-fit algorithm searches for the largest free partition and allocates the process to it. This algorithm is designed to leave the largest possible free partition for future use.
For example, suppose we have the following memory partitions:
| 10 KB | 20 KB | 15 KB | 25 KB | 30 KB |
Now, a process requests 18 KB of memory. The operating system searches for the largest free partition, which is 30 KB. It allocates the process to that partition and keeps the remaining 12 KB as free memory.

#Types Of Processes:
1. *Parent Process
   *Child Process
2. *ForeGround Process
   *BackGround Process
3. *Interactive Process
   *Non-Interactive Process
4. *Zombie Process 
   *Orphan Process
   *Daemon Process

#Exec() Family
1.execv: Program arguments passed as an array of strings --> int execv( const char *path, char *const argv[] );
2.execvp: Searches for the program name in the PATH environment  --> int execvp( const char *file, char *const argv[] );
3.execl: Program arguments passed directly as a list --> int execl( const char *path, const char *arg, ... );
4.execlp: Searches for the program name in the PATH environment --> int execlp( const char *file, const char *arg, ... ); 

#Schedular
1.Long term ( Job Scheduler)
2.Medium term ( swapping scheduler)
3.Short term (CPU scheduler)

#Algorithms
1.FCFS (First Come First Served)
2.SJF (Shortest Job First)
3.Priority
4.RR (Round Robin)

#Address Binding
1.Compile time
2.Load time
3.Execution time

#Memory Allocation Techniques
A)Contiguous
  1.Fixed Partition Scheme: Number of Partitions are fixed & size may or may not be same. Types-->(1)Equal (2)Unequal
  2.Variable Partition Scheme: Number of Partitions are not fixed and Size of partition is same before incoming & varies after process.
B)Non-Contiguous
  1.Paging
  2.Segmentation

#FIFO (First In First Out)
1. Hit ratio
2. Miss Ratio

##Deadlock: When a waiting process requested is never again able to change state because the resource is held by other waiting process. This situation is Deadlock.
  *Two types â€“ (a) preemptable  (b) non-premptable
  *Sequence of events : (a) Request resource   (b) Use resource   (c) release resource
  *Conditions: (a) Mutual exclusion condition: Spool everything
               (b) Hold and wait condition: Request all resources initially  
               (c) No preemption condition: Take resources away  
               (d) Circular wait condition: Order resources numerically 
  *Handling Deadlocks: (a) Ignorance  (b) Prevention  (c) Avoidance  (d) Detection and recovery
  *DeadLock Avoidance: (a) Safe State
                       (b) Unsafe State

#Signals: (a)SIGINT: Interrupt from keyboard(ctrl-c)
          (b)SIGKILL: Kill Program (cannot override or ignore)
          (c)SIGSEGV: Segmentation violation
          (d)SIGALRM: Timer signal
          (e)SIGCHLD: Child stopped & terminated


























